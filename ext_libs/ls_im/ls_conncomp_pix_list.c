/** Extracts list of pixels in connected components generated by spm_bwlabel().
 * Author: Stanislaw Adaszewski, 2012
 */

#include <mex.h>

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    const mxArray *L = prhs[0];
    const mxArray *N = prhs[1];
    double *L_dat;
    const mwSize *L_dim;
    mwSize L_ndim;
    mwSize n;
    mwSize totSize;
    mwSize *counts;
    mwSize N_comp;
    double **offsets;
    mxArray *P;
    mwSize P_dim[2];
    mwSize *filled;
    
    if (nlhs != 1 || nrhs != 2) {
        mexErrMsgTxt("Usage: P = ls_conncomp_pix_list(L, N) where:\n\nL - connected components map\nN - number of connected components");
        return;
    }
    
    if (mxIsEmpty(N) || mxIsComplex(N) || !mxIsDouble(N)) {
        mexErrMsgTxt("N has to be non-empty, real and double.");
        return;
    }
    
    if (mxIsComplex(N) || !mxIsDouble(N)) {
        mexErrMsgTxt("L has to be real and double.");
        return;
    }
    
    N_comp = (mwSize) mxGetPr(N)[0];
    
    L_dat = mxGetPr(L);
    L_ndim = mxGetNumberOfDimensions(L);
    L_dim = mxGetDimensions(L);
    
    totSize = 1;
    for (n = 0; n < L_ndim; n++) {
        totSize *= L_dim[n];
    }
    
    counts = (mwSize*) malloc(sizeof(mwSize) * N_comp);
    memset(counts, 0, sizeof(mwSize) * N_comp);
    filled = (mwSize*) malloc(sizeof(mwSize) * N_comp);
    memset(filled, 0, sizeof(mwSize) * N_comp);
    
    for (n = 0; n < totSize; n++) {
        mwSize comp = (mwSize) L_dat[n];
        if (!comp)
            continue;
        counts[comp-1]++;
    }
    
    /* for (n = 0; n < N_comp; n++) {
        mexPrintf("counts[%d]: %d\n", n+1, counts[n]);
    } */
    
    P_dim[0] = 1;
    P_dim[1] = N_comp;
    P = mxCreateCellArray(2, P_dim);
    
    offsets = (double**) malloc(sizeof(double*) * N_comp);
    for (n = 0; n < N_comp; n++) {
        mwSize A_dim[] = {counts[n], 1};
        mxArray *A = mxCreateNumericArray(2, A_dim, mxDOUBLE_CLASS, mxREAL);
        mxSetCell(P, n, A);
        offsets[n] = mxGetPr(A);
    }
    
    for (n = 0; n < totSize; n++) {
        mwSize comp = (mwSize) L_dat[n];
        if (!comp)
            continue;
        offsets[comp-1][filled[comp-1]] = n + 1;
        filled[comp-1]++;
    }
    
    plhs[0] = P;
}
